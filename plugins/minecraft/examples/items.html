<!doctype html><title>Minimal tQuery Page</title>
<script src="../../../build/tquery-bundle.js"></script>
<body><script>
	var world	= tQuery.createWorld().boilerplate().start();
	var object	= tQuery.createTorus().addTo(world);
	var global	= window;
	var scene	= world.tScene();
	
	world.tCamera().position.z	= 70;
	world.getCameraControls().rangeX	*=	20;
	world.getCameraControls().rangeY	*=	20;

	function getMaterial(image, transparent) {
		var tex		= new THREE.Texture(image);
		tex.magFilter	= THREE.NearestFilter;
		tex.minFilter	= THREE.NearestFilter;
		tex.format	= transparent ? THREE.RGBAFormat : THREE.RGBFormat;
		tex.needsUpdate	= true;
		var material	= new THREE.MeshBasicMaterial({
			map		: tex,
			transparent	: transparent ? true : false
		});
		return material;
	}
	function uvmap (geometry, face, x, y, w, h, rotateBy) {
		if(!rotateBy) rotateBy = 0;
		var uvs = geometry.faceVertexUvs[0][face];
		var tileU = x;
		var tileV = y;
		
		uvs[ (0 + rotateBy) % 4 ].u = tileU * tileUvW;
		uvs[ (0 + rotateBy) % 4 ].v = tileV * tileUvH;
		uvs[ (1 + rotateBy) % 4 ].u = tileU * tileUvW;
		uvs[ (1 + rotateBy) % 4 ].v = tileV * tileUvH + h * tileUvH;
		uvs[ (2 + rotateBy) % 4 ].u = tileU * tileUvW + w * tileUvW;
		uvs[ (2 + rotateBy) % 4 ].v = tileV * tileUvH + h * tileUvH;
		uvs[ (3 + rotateBy) % 4 ].u = tileU * tileUvW + w * tileUvW;
		uvs[ (3 + rotateBy) % 4 ].v = tileV * tileUvH;
	};
	// TODO change that to getGeometry. it is cached
	function getGeometry( id ){
		function getSides(x, y){
			var ix = Math.floor(id % 16)*16;
			var iy = Math.floor(id / 16)*16;
			
			var px = (x+1) < 16? imd[((x+1)+y*16)*4+3] : 0;
			var nx = (x-1) >= 0? imd[((x-1)+y*16)*4+3] : 0;
			var py = (y+1) < 16? imd[(x+(y-1)*16)*4+3] : 0;
			var ny = (y-1) >= 0? imd[(x+(y+1)*16)*4+3] : 0;
			
			return {
				px: !px, // Turns zero and undefined to true
				nx: !nx,
				py: !py,
				ny: !ny,
				pz: true,
				nz: true
			};
		};

		if(geometries[id] !== undefined )	return geometries[id];
		
		var imgdata	= context.getImageData(Math.floor(id % 16)*16, Math.floor(id / 16)*16, 16, 16);
		var imd		= imgdata.data;			
		var geometry	= new THREE.Geometry();
		
		for(var x=0; x < 16; x++) {
			for(var y=0; y < 16; y++) {
				// is this pixel transparent, skip it
				if( imd[(x+y*16)*4+3] === 0)	continue;
				
				var voxel	= new THREE.CubeGeometry(1, 1, 2, 1, 1, 1, undefined, getSides(x, y));
				// TODO why is there a texture here ????
				// - this is a single pixel. get the pixel and set the color
				// - this may fix the anti alias issue
				for(var i=0; i < 6; i++) { // Fix color of voxel
					if(voxel.faceVertexUvs[0][i]) {
						uvmap(voxel, i, Math.floor(id % 16)*16+x, Math.floor(id / 16)*16+y, 1, 1);
					}
				}
				// TODO what is this ... it seems a translation but why ?
				for(var i=0; i < 8; i++) { // Fix voxel's position
					if(voxel.vertices[i]){
						voxel.vertices[i].x += x-7.5;
						voxel.vertices[i].y += -(y-7.5);
					}
				}
				THREE.GeometryUtils.merge(geometry, voxel);
			}
		}
		if( geometry.faces.length === 0 )	geometry = null;
		// cache the result
		geometries[id]	= geometry;
		// return the result
		return geometry;
	};
	function createItem (id) {
		var geometry	= getGeometry(id);
		if( !geometry )	return null;
		
		var mesh	= new THREE.Mesh( geometry, material );
		return mesh;
	};	

	var canvas	= document.createElement('canvas');
	canvas.width	= 256;
	canvas.height	= 256;
	var context	= canvas.getContext('2d');
	var material	= getMaterial(canvas, true);

	var tileUvW	= 1/canvas.width;
	var tileUvH	= 1/canvas.height;
	

	var geometries	= [];
	var supportWebGL= true;

	var items	= new Image();
	items.onload	= function(){
		context.clearRect(0, 0, canvas.width, canvas.height);
		context.drawImage(items, 0, 0);

		var l	= supportWebGL ? 16*16 : 16*8;
		for(var i=0; i < l; i++){
			for(var j=0; j < (supportWebGL?5:1); j++) {
				var item	= createItem(i);
				// if this spot is empty, do nothing
				if( item === null )	continue;
				item.position.x = Math.random()*400-200;
				item.position.y = Math.random()*400-200;
				item.position.z = Math.random()*400-200;
				scene.add(item);
			}
		}
	};
	items.src = "images/items/items.png";
	

</script></body>