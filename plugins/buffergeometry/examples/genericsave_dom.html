<!doctype html><title>Minimal tQuery Page</title>
<script src="../../../build/tquery-bundle.js"></script>
<script src="../tquery.createbuffergeometry.js"></script>
<body><div id='info'>
	<a download='slota.3jsbg' href=''>Download .bin format</a>
</div>
<script>
	var world	= tQuery.createWorld().boilerplate().pageTitle('#info').start();
//	var object	= tQuery.createCube().addTo(world);
//	saveGeometry(object.geometry().get(0))
// call this format .3jsbg
// TODO make a THREE.Geometry to THREE.BufferGeometry
// TODO a THREE.BufferGeometry to file.3jsbg dataview

// put the 

	
	var geometry	= new THREE.Geometry();
	geometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );
	geometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
	geometry.vertices.push( new THREE.Vector3( 1, 0, 0 ) );
	geometry.faces.push( new THREE.Face3(0,1,2) );	
	geometry.faceVertexUvs[0].push([
		new THREE.UV(0, 1),
		new THREE.UV(0, 0),
		new THREE.UV(1, 0)
	]);
	geometry.computeBoundingBox();
	geometry.computeFaceNormals();
	geometry.computeCentroids();
	geometry.computeVertexNormals();
	geometry.computeMorphNormals();
	//geometry.computeTangents();
	geometry.computeBoundingSphere();

	var url		= "../../assets/images/ash_uvgrid01.jpg";
	var tMaterial	= new THREE.MeshBasicMaterial({
		map	: THREE.ImageUtils.loadTexture( url )
	});
	//var tMaterial	= new THREE.MeshNormalMaterial();
	var mesh	= tQuery(geometry, tMaterial).addTo(world);

	//var tBgGeometry	= /*tQuery.*/createBufferGeometry(geometry);
	var dataView	= /*tQuery.*/geometryTo3jsbg(geometry);
	console.log(hexdump(dataView.buffer))

	var blob	= new Blob([dataView], {
		type	: 'application/octet-stream'
	});
	var objectURL	= webkitURL.createObjectURL( blob );
	document.querySelector('#info a').href	= objectURL;


	function createBufferGeometry(tGeometry){
		console.log('tGeometry', tGeometry)
		
		// sanity check
		console.assert(tGeometry instanceof THREE.Geometry );

		// build vertex position array - compatible to THREE.BufferGeometry
		var numItems	= tGeometry.vertices.length;
		var vPosArray	= new Float32Array(numItems * 3);
		tGeometry.vertices.forEach(function(tVertex, index){
			vPosArray[index*3+0]	= tVertex.x;
			vPosArray[index*3+1]	= tVertex.y;
			vPosArray[index*3+2]	= tVertex.z;
		});

		// compute the number of triangles - THREE.BufferGeometry support only triangles
		var numTriangles= 0;
		tGeometry.faces.forEach(function(tFace, index){
			if( tFace instanceof THREE.Face3 )	numTriangles += 1;
			else if( tFace instanceof THREE.Face4 )	numTriangles += 2;
			else console.assert(false);
		});

		// build face indices array - compatible to THREE.BufferGeometry	
		var fIdxArray	= new Int16Array(numTriangles * 3);
		var i		= 0;
		tGeometry.faces.forEach(function(tFace, index){
			if( tFace instanceof THREE.Face3 ){
				fIdxArray[i+0]	= tFace.a;
				fIdxArray[i+1]	= tFace.b;	
				fIdxArray[i+2]	= tFace.c;
				i	+= 3;
			}else if( tFace instanceof THREE.Face4 ){
				fIdxArray[i+0]	= tFace.a;
				fIdxArray[i+1]	= tFace.b;	
				fIdxArray[i+2]	= tFace.c;
				i	+= 3;
				fIdxArray[i+0]	= tFace.b;
				fIdxArray[i+1]	= tFace.c;	
				fIdxArray[i+2]	= tFace.d;
				i	+= 3;
			}else console.assert(false);
		});

		// build face UVs array  - compatible to THREE.BufferGeometry
		var fUvsArray	= new Float32Array(numTriangles * 3 * 2);
		var i		= 0;
		tGeometry.faceVertexUvs[0].forEach(function(faceUvs, index){
			if( faceUvs.length === 3 ){
				fUvsArray[i+0]	= faceUvs[0].u;	fUvsArray[i+1]	= faceUvs[0].v;
				fUvsArray[i+2]	= faceUvs[1].u;	fUvsArray[i+3]	= faceUvs[1].v;
				fUvsArray[i+4]	= faceUvs[2].u;	fUvsArray[i+5]	= faceUvs[2].v;
				i	+= 6;
			}else if( faceUvs.length === 4 ){
				fUvsArray[i+0]	= faceUvs[0].u;	fUvsArray[i+1]	= faceUvs[0].v;
				fUvsArray[i+2]	= faceUvs[1].u;	fUvsArray[i+3]	= faceUvs[1].v;
				fUvsArray[i+4]	= faceUvs[2].u;	fUvsArray[i+5]	= faceUvs[2].v;
				i	+= 6;
				fUvsArray[i+0]	= faceUvs[1].u;	fUvsArray[i+1]	= faceUvs[1].v;
				fUvsArray[i+2]	= faceUvs[2].u;	fUvsArray[i+3]	= faceUvs[2].v;
				fUvsArray[i+4]	= faceUvs[3].u;	fUvsArray[i+5]	= faceUvs[3].v;
				i	+= 6;
			}else	console.assert(false);
		});


		// console.log('vPosArray', vPosArray)
		// console.log('fIdxArray', fIdxArray)
		// console.log('fUvsArray', fUvsArray)

		var geometry		= new THREE.BufferGeometry();
		geometry.attributes	= {
			position	: {
				itemSize: 3,
				array	: vPosArray,
				numItems: vPosArray.length
			},
			index		: {
				itemSize: 1,
				array	: fIdxArray,
				numItems: fIdxArray.length
			},
			uv	: {
				itemSize: 2,
				array	: fUvsArray,
				numItems: fUvsArray.length
			}
		};
		geometry.offsets	= [{
			start	: 0,
			count	: fIdxArray.length,
			index	: 0
		}];

		return geometry;
	}
	
	
	//////////////////////////////////////////////////////////////////////////
	//									//
	//////////////////////////////////////////////////////////////////////////
	/**
	 * build a buffer which store a THREE.BufferGeometry 
	*/
	function geometryTo3jsbg(tBgGeometry){
		// parameter polymorphism
		if( tBgGeometry instanceof THREE.Geometry ){
			tBgGeometry	= tQuery.createBufferGeometry(tBgGeometry);		
		}	
		// sanity check
		console.assert(tBgGeometry instanceof THREE.BufferGeometry );
		// copy parameters 
		var offsets	= tBgGeometry.offsets;
		var vPosArray	= tBgGeometry.attributes.position.array;
		var fIdxArray	= tBgGeometry.attributes.index.array;
		var fUvsArray	= tBgGeometry.attributes.uv.array;
		
		// convert offsets to json
		var offsetsJSON	= JSON.stringify(offsets);
console.log('offsets', offsets, offsetsJSON)
		
		// compute the buffer length
		var bufferLen	= 0;
		bufferLen	+= stringLength(bufferLen,offsetsJSON)
		bufferLen	+= chunkLength(bufferLen, vPosArray);
		bufferLen	+= chunkLength(bufferLen, fIdxArray);
		bufferLen	+= chunkLength(bufferLen, fUvsArray);

		// console.log('bufferLen', bufferLen);

		var inNode	= typeof(window) === 'undefined' ? true : false;
		if( inNode === false ){
			var dataView	= new DataView(new ArrayBuffer(bufferLen));
		}else{
			var dataView	= new Buffer(bufferLen)
		}

		var types	= {
			padding	: 0,
			vertPos	: 1,
			faceIdx	: 2,
			faceUvs	: 3,
			offsets	: 4
		};

		var offset	= 0;
		offset		= stringSave(dataView, offset,types.offsets  , offsetsJSON)
		offset		= chunkSave(dataView, offset, types.vertexPos, vPosArray);
		offset		= chunkSave(dataView, offset, types.vertexIdx, fIdxArray);
		offset		= chunkSave(dataView, offset, types.vertexUvs, fUvsArray);

		return dataView;

		/**
		 * TODO
		 * * improve padding tech
		 * * type of chunck as 8bit
		 * * if type === 0, then skip. in reader
		 * * offset % 4 != 2, then add padding
		 * * how to estimate the size of the output ?
		*/

		//////////////////////////////////////////////////////////////////
		//		to store string					//
		//////////////////////////////////////////////////////////////////
		function stringLength(offset, string){
			var length	= 0;
			// length of the padding
			var padLength	= [3, 2, 1, 0][offset % 4];
			length	+= padLength;
			// length of type - 1byte
			length	+= 1;
			// length of string - 4byte
			length	+= 4;
			// length of the string itself
			length	+= string.length;	
			return length;
		}
		function stringSave(dataView, offset, chunkType, string){
			// write the padding if needed
			var padLength	= [3, 2, 1, 0][offset % 4];
			for(var i = 0; i < padLength; i++){
				dataView.setUint8(offset, types.padding);
				offset		+= 1;
			}
			// write the chunk header
			dataView.setUint8(offset, chunkType);
			offset		+= 1;
			// write the string length
			dataView.setUint32(offset, string.length, false);
			offset		+= 4;

			// copy each char one by one
			// FIXME i doubt it works with non ascii char 
			for(var i = 0; i < string.length; i++){
				dataView.setUint8(offset, string.charCodeAt(i), false);
				offset		+= 1;
			}
			// return the new offset
			return offset;
		}

		//////////////////////////////////////////////////////////////////
		//		to store chunk					//
		//////////////////////////////////////////////////////////////////
		function chunkLength(offset, arr){
			var length	= 0;
			// length of the padding
			var padLength	= [3, 2, 1, 0][offset % 4];
			length	+= padLength;
			// length of type
			length	+= 1;
			// length of nElements
			length	+= 4;
			// length of the array itself
			length	+= arr.byteLength;	
			return length;
		}

		function chunkSave(dataView, offset, chunkType, arr){
			// write the padding if needed
			var padLength	= [3, 2, 1, 0][offset % 4];
			for(var i = 0; i < padLength; i++){
				dataView.setUint8(offset, types.padding);
				offset		+= 1;
			}
			// write the chunk header
			dataView.setUint8(offset, chunkType);
			offset		+= 1;
			// write the array length
			dataView.setUint32(offset, arr.length, false);
			offset		+= 4;
			if( arr.byteLength / arr.length === 4 ){
				// TODO do i have to copy one by one ? isnt there a copy function ?
				for(var i = 0; i < arr.length; i++){
					dataView.setFloat32(offset, arr[i], false);
					offset		+= 4;
				}
			}else if( arr.byteLength / arr.length === 2 ){
				for(var i = 0; i < arr.length; i++){
					dataView.setUint16(offset, arr[i], false);
					offset		+= 2;
				}
			}else	console.assert(false);
			// return the new offset
			return offset;
		}
	}

	//////////////////////////////////////////////////////////////////////////
	// from http://javascript0.org/wiki/Hexdump				//
	// TODO put that in tQuery.console ?					//
	//////////////////////////////////////////////////////////////////////////
	function hexdump(buffer) {
		function hexify(num) {
			var hex		= num.toString(16);
			var zero	= hex.length < 2 ? '0' : ''
			return zero + hex;
		}
		function charify(num) {
			if (num > 0x7e || num < 0x20) { // non-printable
				return '.';
			}
			return String.fromCharCode(num);
		}
		var dv		= new DataView(buffer);
		var offset	= 0;
		var lines	= [];
		while(offset < buffer.byteLength){
			var chars = '';
			var hexes = '';
			for (var i = 0; i < 16; i++) {
				if (offset < buffer.byteLength) {
					byte = dv.getUint8(offset);
					chars += charify(byte);
					hexes += hexify(byte);
				} else {
					chars += ' ';
					hexes += '  '
				}
				hexes += ' ';
				if (i == 7) {
					hexes += ' ';
				}
				offset += 1;
			}
			lines.push(hexes + '  |' + chars + '|');
		}
		return lines.join('\n');
	}
</script></body>