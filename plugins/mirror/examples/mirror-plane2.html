<!doctype html><title>Minimal tQuery Page</title>
<script src="../../../build/tquery-bundle-require.js"></script>
<body><script>
require([ 'tquery.skymap'
	, 'tquery.grassground'
	, 'tquery.minecraft'
], function(){
	var world	= tQuery.createWorld().boilerplate().start();

	tQuery.createSkymap('bridge2').addTo(world);
	
	var container	= tQuery.createObject3D().addTo(world).positionY(-0.5)
	tQuery.createTorusKnot().addTo(container).position( 0, 0, 1)
	// tQuery.createTorusKnot().addTo(container).position( 0, 0,-3)
	// tQuery.createTorusKnot().addTo(container).position( 3, 0, 0).rotateY( Math.PI/2)
	// tQuery.createTorusKnot().addTo(container).position(-3, 0, 0).rotateY(-Math.PI/2)
	
	world.hook(function(delta, now){
		container.rotateY( 0.3 * delta * Math.PI*2)
	})
	
	
	var textureW	= 1024;
	var textureH	= 1024;
	var rtTexture	= new THREE.WebGLRenderTarget(textureW, textureH, {
		minFilter	: THREE.LinearFilter,
		magFilter	: THREE.NearestFilter,
		format		: THREE.RGBFormat
	});
	
	var mirror	= tQuery.createPlane().addTo(world)
		.scaleX(1)
		.scaleY(textureH/textureW)
		.setBasicMaterial()
			.map(rtTexture)
			.back()


	var tPlaneCam	= new THREE.PerspectiveCamera(20, textureW/textureH, 0.0001, 10000);
	var mirrorCamera= tQuery(tPlaneCam).addTo(world)
	
	// var cameraPerspectiveHelper = new THREE.CameraHelper( mirrorCamera.get(0) );
	// world.tScene().add( cameraPerspectiveHelper );

	tQuery.createAxis().addTo(mirrorCamera)
	var cameraObj	= tQuery.createCube().addTo(mirrorCamera)
		.scale(1/10)
		.setBasicMaterial()
			.wireframe(true)
			.color('hotpink')
			.back()
	
	// Render the scene
	world.hook(function(delta, now){
		var tRenderer	= world.tRenderer();
		tRenderer.render(world.tScene(), mirrorCamera.get(0), rtTexture, true);	
		
		//cameraPerspectiveHelper.update();
		//cameraPerspectiveHelper.visible = true;

	})
	
	
	world.hook(function(delta, now){
		mirrorCamera.lookAt(0,0,0)
		mirrorCamera.positionX( world.camera().positionX() )
		mirrorCamera.positionY( world.camera().positionY() )
		mirrorCamera.positionZ(-world.camera().positionZ() )
		
		var tCamera	= mirrorCamera.get(0)
		var distance	= tCamera.position.length();
		tCamera.fov	= Math.atan2(1/tCamera.aspect, distance)*180/Math.PI;
		tCamera.near	= distance;
		tCamera.updateProjectionMatrix();
	})
})
</script></body>