<html><head>
	<script src="vendor/JSARToolKit.js"></script>
	<script src="vendor/Three.js"></script>
	<script src="vendor/requestanimationframe.js"></script>
	<link  href='main.css' rel="stylesheet" />
<script>
	// TODO setFromArray is like setFromGLMatrix
	// - FIXME dont modify
	THREE.Matrix4.prototype.setFromArray = function(m) {
		return this.set(
			m[0], m[4], m[8], m[12],
			m[1], m[5], m[9], m[13],
			m[2], m[6], m[10], m[14],
			m[3], m[7], m[11], m[15]
		);
	};
	// rename this function
	function copyMatrix(mat, cm) {
		cm[0] = mat.m00;
		cm[1] = -mat.m10;
		cm[2] = mat.m20;
		cm[3] = 0;
		cm[4] = mat.m01;
		cm[5] = -mat.m11;
		cm[6] = mat.m21;
		cm[7] = 0;
		cm[8] = -mat.m02;
		cm[9] = mat.m12;
		cm[10] = -mat.m22;
		cm[11] = 0;
		cm[12] = mat.m03;
		cm[13] = -mat.m13;
		cm[14] = mat.m23;
		cm[15] = 1;
	}

	var threshold	= 128;
	// to enable/disable debug output in jsartoolkit
	DEBUG		= true;
	
	// create the video element for the webcam
	var video	= document.createElement('video');
	video.width	= 320;
	video.height	= 240;
	video.loop	= true;
	video.volume	= 0;
	video.autoplay	= true;
	video.controls	= true;

	var getUserMedia = function(t, onsuccess, onerror) {
		if (navigator.getUserMedia) {
			return navigator.getUserMedia(t, onsuccess, onerror);
		} else if (navigator.webkitGetUserMedia) {
			return navigator.webkitGetUserMedia(t, onsuccess, onerror);
		} else if (navigator.mozGetUserMedia) {
			return navigator.mozGetUserMedia(t, onsuccess, onerror);
		} else if (navigator.msGetUserMedia) {
			return navigator.msGetUserMedia(t, onsuccess, onerror);
		} else {
			onerror(new Error("No getUserMedia implementation found."));
		}
	};
	
	var URL = window.URL || window.webkitURL;
	var createObjectURL = URL.createObjectURL || webkitURL.createObjectURL;
	if (!createObjectURL){
		throw new Error("URL.createObjectURL not found.");
	}

	getUserMedia('video', function(stream) {
		var url = createObjectURL(stream);
		video.src = url;
	}, function(error) {
		alert("Couldn't access webcam.");
	});
	
	var onload	= function() {
		document.getElementById('loading').style.display = 'none';
		document.body.appendChild(video);
	      
		var canvas = document.createElement('canvas');
		canvas.width	= 320;
		canvas.height	= 240;
		document.body.appendChild(canvas);
	      
		// apparently debug canvas is directly updated by jsartoolkit
		// - usefull to get debug info for tunning
		// - FIXME the way it is exported is dirty tho
		var debugCanvas		= document.createElement('canvas');
		debugCanvas.id		= 'debugCanvas';
		debugCanvas.width	= 320;
		debugCanvas.height	= 240;
		document.body.appendChild(debugCanvas);
	      
		var videoCanvas		= document.createElement('canvas');
		videoCanvas.width	= video.width;
		videoCanvas.height	= video.width*3/4;
	      
		var ctx		= canvas.getContext('2d');
	      
		var arRaster	= new NyARRgbRaster_Canvas2D(canvas);
		var param	= new FLARParam(320,240);
	      
		var arDetector	= new FLARMultiIdMarkerDetector(param, 120);
		arDetector.setContinueMode(true);
	      
	      
		var tmp		= new Float32Array(16);
	      
		var renderer	= new THREE.WebGLRenderer();
		renderer.setSize(960/2, 720/2);
	      
		var glCanvas	= renderer.domElement;
		//document.body.appendChild(glCanvas);
		document.body.insertBefore(glCanvas, document.body.firstChild);

		var scene	= new THREE.Scene();
		var light	= new THREE.PointLight(0xffffff);
		light.position.set(400, 500, 100);
		scene.add(light);
		var light	= new THREE.PointLight(0xffffff);
		light.position.set(-400, -500, -100);
		scene.add(light);
	      
		// Create a camera and a marker root object for your Three.js scene.
		var camera = new THREE.Camera();
		scene.add(camera);
		
		// Next we need to make the Three.js camera use the FLARParam matrix.
		param.copyCameraMatrix(tmp, 10, 10000);
		camera.projectionMatrix.setFromArray(tmp);
	      
		var videoTex = new THREE.Texture(videoCanvas);
	      
		// Create scene and quad for the video.
		var plane = new THREE.Mesh(
			new THREE.PlaneGeometry(2, 2, 0),
			new THREE.MeshBasicMaterial({map: videoTex})
		);
		plane.material.depthTest = false;
		plane.material.depthWrite = false;
		var videoCam = new THREE.Camera();
		var videoScene = new THREE.Scene();
		videoScene.add(plane);
		videoScene.add(videoCam);
	      
		var times = [];
		var markers = {};
		var lastTime = 0;
		

		var onRender	= function(){
			
			if (video.ended) video.play();
			if (video.paused) return;
			if (window.paused) return;
			if (video.currentTime == video.duration) {
				video.currentTime = 0;
			}
			if (video.currentTime == lastTime) return;
			lastTime = video.currentTime;
			
			videoCanvas.getContext('2d').drawImage(video,0,0);
			ctx.drawImage(videoCanvas, 0,0,320,240);
		      
			canvas.changed = true;
			videoTex.needsUpdate = true;
			
			// detect markers
			var nDetected	= arDetector.detectMarkerLite(arRaster, threshold);
			var tmpArMat	= new NyARTransMatResult();
			for (var idx = 0; idx < nDetected; idx++) {
				var markerId;
				// extract the markerId
				var id	= arDetector.getIdMarkerData(idx);
				if (id.packetLength > 4) {
					markerId = -1;
				}else{
					markerId = 0;
					for (var i = 0; i < id.packetLength; i++ ) {
						markerId = (markerId << 8) | id.getPacketData(i);
					}
				}
				// define the marker if needed
				markers[markerId] = markers[markerId] || {};
				
				markers[markerId].age = 0;
				// FIXME Object.asCopy is a dirty kludge - jsartoolkit is declaring this on global space 
				arDetector.getTransformMatrix(idx, tmpArMat);
				markers[markerId].transform = Object.asCopy(tmpArMat);
			}
			// handle markers age
			Object.keys(markers).forEach(function(markerId){
				var marker = markers[markerId];
				if( marker.age > 1) {
					delete markers[markerId];
					scene.remove(marker.object3d);
				}
				marker.age++;
			});
			// create and update object3d associated to markers
			Object.keys(markers).forEach(function(markerId){
				var marker = markers[markerId];
				if (!marker.object3d) {
					marker.object3d = new THREE.Object3D();
					var cube = new THREE.Mesh(
						new THREE.CubeGeometry(100,100,100),
						new THREE.MeshLambertMaterial({color: 0|(0xffffff*Math.random())})
					);
					cube.position.z = -50;
					cube.doubleSided = true;
					marker.object3d.matrixAutoUpdate = false;
					marker.object3d.add(cube);
					scene.add(marker.object3d);
				}
				copyMatrix(marker.transform, tmp);
				marker.object3d.matrix.setFromArray(tmp);
				marker.object3d.matrixWorldNeedsUpdate = true;				
			});
			
			// trigger the rendering
			renderer.autoClear = false;
			renderer.clear();
			renderer.render(videoScene, videoCam);
			renderer.render(scene, camera);
		};

		requestAnimationFrame(function(){
			requestAnimationFrame(arguments.callee)
			onRender()
		})
	}
	window.onload	= onload;

</script>
</head>
<body>
	<div id="loading">loading...</div>
</body>
</html>
